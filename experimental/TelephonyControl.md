# Controlling Telephony and speech specific behavior
To allow speech specific functionality, the botframework SDK has extended existing APIs and implemented a new one for recording.

## Allow/disable barge in
If the user generates input to the bot (either speech or [DTMF](https://en.wikipedia.org/wiki/Dual-tone_multi-frequency_signaling)) while the bot is playing a message, the bot will stop the playback. This behavior is known as "barge in". Sometimes it is necessary, due to legal or compliance requirements, to disallow barge in for the duration of a message.

To disable barge in, the activity must have `IgnoringInput` as the input hint value. The input hint affects only the message it was applied to, not any subsequent messages.

```csharp
protected override async Task OnMembersAddedAsync(IList<ChannelAccount> membersAdded, ITurnContext<IConversationUpdateActivity> turnContext, CancellationToken cancellationToken)
{
    foreach (var member in membersAdded)
    {
        if (member.Id != turnContext.Activity.Recipient.Id)
        {
            // This message can't be interrupted by the user
            var recordingCallMessage = "This call may be recorded for quality assurance purposes.";
            await turnContext.SendActivityAsync(MessageFactory.Text(recordingCallMessage, recordingCallMessage, InputHints.IgnoringInput), cancellationToken);

            // This message can be interrupted by the user
            var supportingCallMessage = "What can I help you with today?";
            await turnContext.SendActivityAsync(MessageFactory.Text(supportingCallMessage, supportingCallMessage), cancellationToken);
        }
    }
}
```

_Note:_ In the Public Preview release, barge in only works for DTMF input (in other words, when _not_ using `InputHints.IgnoringInput`, speech input will be buffered up and sent to the bot after the end of message playback). This is a known limitation that will be resolved in the GA release.

## DTMF input

DTMF input is passed to the bot in the `Text` field of the activity object. Possible DTMF characters are digits from `0` to `9`, `*` (star) and `#` (pound). DTMF input is not localized.

Activities generated by speech and the telephone keypad are not combined. For example, saying 'fourty' and pressing &#9313; on the keypad will result in two separate activities.

It is sometimes necessary to distinguish voice from DTMF input, i.e. whether the user spoke an utterance or pressed it on the telephone keypad. 

An activity that was generated by the telephone keypad can be recognized by the presence of the DTMF entity attached to its `Entities` list. 

Example:

```csharp
protected override async Task OnMessageActivityAsync(ITurnContext<IMessageActivity> turnContext, CancellationToken cancellationToken)
{
    string response;
    if (turnContext.Activity.Entities.Any(entity => entity.Type == "DTMF"))
    {
        response = $"You have pressed DTMF button(s) {turnContext.Activity.Text}";
    }
    else
    {
        response = $"You have said {turnContext.Activity.Text}";
    }
}
```
_Note:_ In the Public Preview release, every individual key press is sent to the bot as a separate activity. The ability to "batch" multiple DTMF signals in a single activity will be added in the GA release.

## Start recording, stop recording, and attach metadata to the recording
Telephony extensions package offers “StartRecording”,“StopRecording”, and "ResumeRecording" methods, which have channel specific implementations.

StartRecording when called, starts recording the conversation. StopRecording when called stops recording the conversation.

ResumeRecording when called, resumes recording the conversation, appending the new section of the recording to the previously started recording for this conversation.

If StopRecording is never called, the recording must be stopped when the channel ends the conversation

If a recording is started for a conversation (On any storage path), recording cannot be started elsewhere. Channel should return an error indicating that the "Recording is already in progress" in this case, and otherwise do nothing. This will require the channel to ensure some synchronization so that no race condition is experienced by consumers of this API.

If StopRecording is called and there is no recording in progress, channel should return an error indicating that the "Recording has not started".

If a recording for a single conversation is paused and resumed again, the recordings should be appended in storage.

If a recording for a single conversation is stopped and started again, the recordings appear as multiple recording sessions in the storage.

```csharp
public class TelephonyExtensions
{
    public static readonly string RecordingStart = "recording_start_command";

    public static Activity CreateRecordingStartCommand()
    {
        var startRecordingActivity = new Activity(ActivityTypesWithCommand.Command)
        {
            Name = RecordingStart;
            Value = new CommandValue<RecordingStartSettings>()
        };

        return startRecordingActivity;
    }
}
```

Call Pattern
```csharp
protected override async Task OnMembersAddedAsync(IList<ChannelAccount> membersAdded, ITurnContext<IConversationUpdateActivity> turnContext, CancellationToken cancellationToken)
{
    foreach (var member in membersAdded)
    {
        // Greet anyone that was not the target (recipient) of this message.
        if (member.Id != turnContext.Activity.Recipient.Id)
        {
            // Start recording when the call begins
            await turnContext.SendActivityAsync(TelephonyExtensions.CreateRecordingStartCommand(), cancellationToken);

            var response = VoiceFactory.TextAndVoice($"Welcome to {CompanyName}! This call may be recorded for quality assurance purposes.");
            await turnContext.SendActivityAsync(response, cancellationToken);

            await Dialog.RunAsync(turnContext, ConversationState.CreateProperty<DialogState>("DialogState"), cancellationToken);
        }
    }
}

protected override async Task OnRecordingStartResultAsync(ITurnContext<ICommandResultActivity> turnContext, CancellationToken cancellationToken)
{
    var result = CommandExtensions.GetCommandResultValue<object>(turnContext.Activity);

    // Check if recording started successfully
    if (result.Error != null)
    {
        var recordingFailed = VoiceFactory.TextAndVoice($"Recording has failed, but your call will continue.");
        wait turnContext.SendActivityAsync(recordingStatusText, cancellationToken);
    }
}
```
